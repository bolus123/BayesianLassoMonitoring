if (dd5 > dd31) {
grandsig <- TRUE
}
lim <- dd31
sig <- dd4 > lim
names(dd31) = NULL
list("grandsig" = grandsig, "grandstat" = dd5, "grandlim" = dd31,
"sig" = sig, "cs" = dd4, "lim" = dd31, "Yph1" = ph1mat)
}
ee <- Ph1MultipleTesting.YJSum(bb, FAP0 = 0.2, side = "right-sided",
updateYJ = 1, leftcensoring = 1, rounding = 1, eps = 1e-32,
backtr = 1, nsim = 100000)
ff <- Ph1MultipleTesting.YJMax(bb, FAP0 = 0.2, side = "right-sided",
updateYJ = 1, leftcensoring = 1, rounding = 1, eps = 1e-32,
backtr = 1, nsim = 100000)
ee$lim
ee$cs
ee$grandsig
ee$sig
which(ee$sig)
ee$lim
ee$grandlim
ee$grandstat
ee$grandlim
ee$lim
X
ff$grandsig
ff$grandstat
ff$grandlim
ff$sig
ff$cs
X
pars[X, ]
1 - 0.2/360
1 - (1 - 0.2/360)
1 - (1 - 0.2) ^ (1/360)
1 - (1 - 0.2) ^ (1/720)
1 - (1 - 0.2) ^ (1/1000)
(1 - 0.2) ^ (1/1000)
Ph1MultipleTesting.YJSum <- function(model, FAP0 = 0.2, side = "right-sided",
updateYJ = 1, leftcensoring = 1, rounding = 1, eps = 1e-32,
backtr = 1, nsim = 10000) {
Y <- model$Y
q <- dim(model$Phi)[1]
n <- length(model$Y)
nnsim <- dim(model$Phi)[2]
ph1mat <- matrix(NA, nrow = n - q, ncol = nsim)
for (i in 1:nsim) {
tmpsel <- sample(1:nnsim, 1)
Mu0 <- matrix(rep(model$mu0[tmpsel], n))
if (!is.null(model$X)) {
Mu0 <- Mu0 + model$X %*% (model$Beta[, tmpsel] * model$Zeta[, tmpsel])
}
ph1mat[, i] <- simYph2(0, as.matrix(model$Y), as.matrix(model$Z[, tmpsel]), as.matrix(model$Phi[, tmpsel]),
Mu0, model$sigma2[tmpsel], updateYJ, model$theta[tmpsel],
leftcensoring, rounding, eps, backtr)
}
mm <- rowMeans(ph1mat)
ss <- apply(ph1mat, 1, sd)
dd2 <- matrix(NA, nrow = n - q, ncol = nsim)
for (i in 1:nsim) {
dd2[, i] <- ((ph1mat[, i] - mm) / ss) ^2
}
if (side == "left-sided") {
for (i in 1:(n - q)) {
dd2[i, which(ph1mat[i, ] > mm[i])] <- 0
}
} else if (side == "right-sided") {
for (i in 1:(n - q)) {
dd2[i, which(ph1mat[i, ] < mm[i])] <- 0
}
}
dd3 <- colSums(dd2)
dd31<- quantile(dd3, 1 - FAP0)
dd4 <- ((Y[-c(1:q)] - mm) / ss)^2
if (side == "left-sided") {
for (i in 1:(n - q)) {
dd4[which(Y[-c(1:q)] > mm)] <- 0
}
} else if (side == "right-sided") {
for (i in 1:(n - q)) {
dd4[which(Y[-c(1:q)] < mm)] <- 0
}
}
dd5 <- sum(dd4)
grandsig <- FALSE
if (dd5 > dd31) {
grandsig <- TRUE
}
lim <- apply(dd2, 1, quantile, (1 - FAP0) ^ (1 / (n - q)))
sig <- dd4 > lim
names(dd31) = NULL
list("grandsig" = grandsig, "grandstat" = dd5, "grandlim" = dd31, "pvalue" = mean(dd5 > dd3),
"sig" = sig, "cs" = dd4, "lim" = lim, "pvalues" = rowMeans(dd4 > dd2), "Yph1" = ph1mat)
}
ee <- Ph1MultipleTesting.YJSum(bb, FAP0 = 0.2, side = "right-sided",
updateYJ = 1, leftcensoring = 1, rounding = 1, eps = 1e-32,
backtr = 1, nsim = 100000)
ee$pvalues
ee$pvalue
Ph1MultipleTesting.YJSum <- function(model, FAP0 = 0.2, side = "right-sided",
updateYJ = 1, leftcensoring = 1, rounding = 1, eps = 1e-32,
backtr = 1, nsim = 10000) {
Y <- model$Y
q <- dim(model$Phi)[1]
n <- length(model$Y)
nnsim <- dim(model$Phi)[2]
ph1mat <- matrix(NA, nrow = n - q, ncol = nsim)
for (i in 1:nsim) {
tmpsel <- sample(1:nnsim, 1)
Mu0 <- matrix(rep(model$mu0[tmpsel], n))
if (!is.null(model$X)) {
Mu0 <- Mu0 + model$X %*% (model$Beta[, tmpsel] * model$Zeta[, tmpsel])
}
ph1mat[, i] <- simYph2(0, as.matrix(model$Y), as.matrix(model$Z[, tmpsel]), as.matrix(model$Phi[, tmpsel]),
Mu0, model$sigma2[tmpsel], updateYJ, model$theta[tmpsel],
leftcensoring, rounding, eps, backtr)
}
mm <- rowMeans(ph1mat)
ss <- apply(ph1mat, 1, sd)
dd2 <- matrix(NA, nrow = n - q, ncol = nsim)
for (i in 1:nsim) {
dd2[, i] <- ((ph1mat[, i] - mm) / ss) ^2
}
if (side == "left-sided") {
for (i in 1:(n - q)) {
dd2[i, which(ph1mat[i, ] > mm[i])] <- 0
}
} else if (side == "right-sided") {
for (i in 1:(n - q)) {
dd2[i, which(ph1mat[i, ] < mm[i])] <- 0
}
}
dd3 <- colSums(dd2)
dd31<- quantile(dd3, 1 - FAP0)
dd4 <- ((Y[-c(1:q)] - mm) / ss)^2
if (side == "left-sided") {
for (i in 1:(n - q)) {
dd4[which(Y[-c(1:q)] > mm)] <- 0
}
} else if (side == "right-sided") {
for (i in 1:(n - q)) {
dd4[which(Y[-c(1:q)] < mm)] <- 0
}
}
dd5 <- sum(dd4)
grandsig <- FALSE
if (dd5 > dd31) {
grandsig <- TRUE
}
lim <- apply(dd2, 1, quantile, (1 - FAP0) ^ (1 / (n - q)))
sig <- dd4 > lim
names(dd31) = NULL
list("grandsig" = grandsig, "grandstat" = dd5, "grandlim" = dd31, "pvalue" = 1 - mean(dd5 > dd3),
"sig" = sig, "cs" = dd4, "lim" = lim, "pvalues" = 1 - rowMeans(dd4 > dd2), "Yph1" = ph1mat)
}
#' Bayesian LASSO Phase I Monitoring
#'
#' gets a posterior sample using Gibbs sampling for Random Flexible Level Shift Model
#' @param model is model.
#' @param nsim is .
#' @param FAP0 is
#' @param log is model.
#' @param const is .
#' @param sta is
#'
#'
#' @export
Ph1MultipleTesting.YJMax <- function(model, FAP0 = 0.2, side = "right-sided",
updateYJ = 1, leftcensoring = 1, rounding = 1, eps = 1e-32,
backtr = 1, nsim = 10000) {
Y <- model$Y
q <- dim(model$Phi)[1]
n <- length(model$Y)
nnsim <- dim(model$Phi)[2]
ph1mat <- matrix(NA, nrow = n - q, ncol = nsim)
for (i in 1:nsim) {
tmpsel <- sample(1:nnsim, 1)
Mu0 <- matrix(rep(model$mu0[tmpsel], n))
if (!is.null(model$X)) {
Mu0 <- Mu0 + model$X %*% (model$Beta[, tmpsel] * model$Zeta[, tmpsel])
}
ph1mat[, i] <- simYph2(0, as.matrix(model$Y), as.matrix(model$Z[, tmpsel]), as.matrix(model$Phi[, tmpsel]),
Mu0, model$sigma2[tmpsel], updateYJ, model$theta[tmpsel],
leftcensoring, rounding, eps, backtr)
}
mm <- rowMeans(ph1mat)
ss <- apply(ph1mat, 1, sd)
dd2 <- matrix(NA, nrow = n - q, ncol = nsim)
for (i in 1:nsim) {
dd2[, i] <- ((ph1mat[, i] - mm) / ss) ^2
}
if (side == "left-sided") {
for (i in 1:(n - q)) {
dd2[i, which(ph1mat[i, ] > mm[i])] <- 0
}
} else if (side == "right-sided") {
for (i in 1:(n - q)) {
dd2[i, which(ph1mat[i, ] < mm[i])] <- 0
}
}
dd3 <- apply(dd2, 2, max)
dd31<- quantile(dd3, 1 - FAP0)
dd4 <- ((Y[-c(1:q)] - mm) / ss)^2
if (side == "left-sided") {
for (i in 1:(n - q)) {
dd4[which(Y[-c(1:q)] > mm)] <- 0
}
} else if (side == "right-sided") {
for (i in 1:(n - q)) {
dd4[which(Y[-c(1:q)] < mm)] <- 0
}
}
dd5 <- max(dd4)
grandsig <- FALSE
if (dd5 > dd31) {
grandsig <- TRUE
}
lim <- dd31
sig <- dd4 > lim
names(dd31) = NULL
list("grandsig" = grandsig, "grandstat" = dd5, "grandlim" = dd31, "pvalue" = 1 - mean(dd5 > dd3),
"sig" = sig, "cs" = dd4, "lim" = dd31, "pvalues" = 1 - rowMeans(dd4 > dd2), "Yph1" = ph1mat)
}
ee <- Ph1MultipleTesting.YJSum(bb, FAP0 = 0.2, side = "right-sided",
updateYJ = 1, leftcensoring = 1, rounding = 1, eps = 1e-32,
backtr = 1, nsim = 100000)
ff <- Ph1MultipleTesting.YJMax(bb, FAP0 = 0.2, side = "right-sided",
updateYJ = 1, leftcensoring = 1, rounding = 1, eps = 1e-32,
backtr = 1, nsim = 100000)
ee$pvalues
ee$grandsig
ee$pvalue
ff$pvalue
ff$pvalues
ee$pvalues
ff$pvalues
ee$pvalues
p.adjust(ee$pvalues, "holm")
p.adjust(ee$pvalues, "BH")
p.adjust(ee$pvalues)
?p.adjust
ee$grandsig
ff$grandsig
ee$pvalues
p.adjust(ee$pvalues, "bonferronni")
p.adjust(ee$pvalues, "bonferroni")
ee$sig
ee$cs
ff$pvalues
ff$pvalue
ff$grandlim
ff$grandstat
ff$grandsig
ee$pvalue
ee$sig
ee$lim
ee$cs
ee$lim
ee$sig
which(ee$sig)
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H1 <- H1[, seq(1, TT1 - q, 1)]
H1 <- H1[, -c(colSums(H1) < 1)]
H1
dim(H1)
getChart <- function(Y1, H1, Y0,
side, FAP0,
Y2, H2, tt, TT1, bset) {
##chart1 <- try(BayesianLASSOMonitoring::GibbsRFLSMYJZ(Y1, H1, method = method, nsim = 300, by = 10, burnin = 3000 / 0.8 * 0.2), silent = TRUE)
chart1 <- try(BayesianLASSOMonitoring::GibbsRFLSMXYJZ(as.matrix(Y1), bset, H = H1), silent = TRUE)
chart2 <- try(BayesianLASSOMonitoring::Ph1MultipleTesting.Y01(chart1, FAP0 = FAP0, side = side,
updateYJ = bset$updateYJ,
leftcensoring = bset$leftcensoring, rounding = bset$rounding,
nsim = 100000, backtr = 1), silent = TRUE)
chart3 <- try(BayesianLASSOMonitoring::Ph1MultipleTesting.YJSum(chart1, FAP0 = FAP0, side = side,
updateYJ = bset$updateYJ,
leftcensoring = bset$leftcensoring, rounding = bset$rounding, eps = bset$eps,
backtr = 1, nsim = 100000), silent = TRUE)
chart4 <- try(BayesianLASSOMonitoring::Ph1MultipleTesting.YJMax(chart1, FAP0 = FAP0, side = side,
updateYJ = bset$updateYJ,
leftcensoring = bset$leftcensoring, rounding = bset$rounding, eps = bset$eps,
backtr = 1, nsim = 100000), silent = TRUE)
Yph1 <- matrix(NA, nrow = length(Y1) - bset$q, ncol = 10000)
Yph2 <- matrix(NA, nrow = length(Y2), ncol = 10000)
if (class(chart1)[1] != "try-error") {
tmpMu1 <- H1 %*% (chart1$Gamma * chart1$Tau)
tmpMu2 <- H2 %*% (chart1$Gamma * chart1$Tau)
tmpMu2 <- rbind(tmpMu1, tmpMu2)
h <- dim(H2)[1]
for (ii in 1:10000) {
tmpsel <- sample(1:300, 1)
Mu1 <- chart1$mu0[tmpsel] + tmpMu2[, tmpsel]
tmp <- BayesianLASSOMonitoring::simYph2(h, as.matrix(chart1$Y), as.matrix(chart1$Z[, tmpsel]),
as.matrix(chart1$Phi[, tmpsel]), Mu1, chart1$sigma2[tmpsel],
bset$updateYJ, bset$theta, bset$leftcensoring, bset$rounding, bset$eps)
Yph1[, ii] <- tmp[1:(length(chart1$Y) - bset$q)]
Yph2[, ii] <- tmp[(length(chart1$Y)  - bset$q + 1):length(tmp)]
}
}
ph1pestmedian <- rep(NA, length(Y1) - bset$q)
if ((class(chart1)[1] != "try-error")) {
for (ii in 1:(length(Y1)  - bset$q)) {
ph1pestmedian[ii] <- median(Yph1[ii, ], na.rm = TRUE)
}
}
ph2pestmedian <- rep(NA, length(Y2))
if (class(chart1)[1] != "try-error") {
for (ii in 1:length(Y2)) {
ph2pestmedian[ii] <- median(Yph2[ii, ], na.rm = TRUE)
}
}
out <- rep(NA, 6)
if ((class(chart1)[1] != "try-error") & (class(chart2)[1] != "try-error")) {
q <- dim(chart1$Phi)[1]
RMSE.ph1.median <- sqrt(mean((Y1[-c(1:q)] - ph1pestmedian) ^ 2, na.rm = TRUE))
RMSE.ph2.median <- sqrt(mean((Y2 - ph2pestmedian) ^ 2, na.rm = TRUE))
out <- c(RMSE.ph1.median,
RMSE.ph2.median)
start.exact <- ceiling(TT1 * tt)
end <- ceiling(TT1 * tt)
###############################################
#chart 2
###############################################
TP.app <- sum(chart2$sig[start.exact:end], na.rm =TRUE)
FN.app <- sum(1 - chart2$sig[start.exact:end], na.rm =TRUE)
sensitivity.app <- TP.app / (TP.app + FN.app)
TN.app <- sum(1 - chart2$sig[-c(start.exact:end)], na.rm =TRUE)
FP.app <- sum(chart2$sig[-c(start.exact:end)], na.rm =TRUE)
specificity.app <- TN.app / (TN.app + FP.app)
ppv.app <- TP.app / (TP.app + FP.app)
sig <- chart2$grandsig
out <- c(out, sig,
sensitivity.app,
specificity.app,
ppv.app)
###############################################
#chart 3
###############################################
TP.app <- sum(chart3$sig[start.exact:end], na.rm =TRUE)
FN.app <- sum(1 - chart3$sig[start.exact:end], na.rm =TRUE)
sensitivity.app <- TP.app / (TP.app + FN.app)
TN.app <- sum(1 - chart3$sig[-c(start.exact:end)], na.rm =TRUE)
FP.app <- sum(chart3$sig[-c(start.exact:end)], na.rm =TRUE)
specificity.app <- TN.app / (TN.app + FP.app)
ppv.app <- TP.app / (TP.app + FP.app)
sig <- chart3$grandsig
out <- c(out, sig,
sensitivity.app,
specificity.app,
ppv.app)
###############################################
#chart 4
###############################################
TP.app <- sum(chart4$sig[start.exact:end], na.rm =TRUE)
FN.app <- sum(1 - chart4$sig[start.exact:end], na.rm =TRUE)
sensitivity.app <- TP.app / (TP.app + FN.app)
TN.app <- sum(1 - chart4$sig[-c(start.exact:end)], na.rm =TRUE)
FP.app <- sum(chart4$sig[-c(start.exact:end)], na.rm =TRUE)
specificity.app <- TN.app / (TN.app + FP.app)
ppv.app <- TP.app / (TP.app + FP.app)
sig <- chart4$grandsig
out <- c(out, sig,
sensitivity.app,
specificity.app,
ppv.app)
###############################################
}
return(out)
}
simulation.wrap <- function(X, pars, alpha, lambda, pi, seed = 12345) {
cat("start at X:", X, "\n")
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
Y <- BayesianLASSOMonitoring::rzinpoisinar3(TT1 + TT2 + w - 1, alpha, lambda, pi,
ceiling(TT1 * tt) + w - 1, delta = delta, burnin = 100)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
#H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
#H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
#H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
if (w > 1) {
H1 <- H1[, seq(1, TT1 - q, w)]
H1 <- H1[, -c(colSums(H1) < w)]
}
H2<- matrix(1, nrow = TT2, ncol = dim(H1)[2])
H2sim <- matrix(1, nrow = 5000, ncol = dim(H1)[2])
bset1 <- list(
"method" = "MT",
"mono" = 0,
"q" = 5,
"A" = diag(nrow = 5),
"bound0" = Inf,
"boundqplus1" = 0,
"xi2" = 0.1,
"theta1" = 1,
"theta2" = 1,
"a" = 1,
"b" = 1,
"alpha" = 1,
"beta" = 1,
"updateYJ" = 1,
"leftcensoring" = 1,
"rounding" = 1,
"theta" = 1,
"eps" = 1e-32,
"nsim" = 300,
"thin" = 10,
"burnin" = 2000
)
bset2 <- bset1
bset2$method <- "regression"
bset2$mono <- 0
bset3 <- bset1
bset3$method <- "LASSO"
bset3$mono <- 0
bset4 <- bset1
bset4$method <- "ALASSO"
bset4$mono <- 0
bset5 <- bset1
bset5$method <- "LASSO"
bset5$mono <- 1
bset6 <- bset1
bset6$method <- "ALASSO"
bset6$mono <- 1
##ee <- BayesianLASSOMonitoring::GibbsRFLSMYJZ(Y1, H1)
#ww <- Ph1MultipleTesting.Y0tr(ee)
#X <- BayesianLASSOMonitoring::getXSeasonalityFS(TT1 + 5000, 3.5, 3)
#X1 <- X[1:TT1, ]
#X2 <- X[(TT1 + 1):(TT1 + TT2), ]
#X2sim <- X[(TT1 + 1):(TT1 + 5000), ]
out <- rep(NA, 6 * 6)
out1 <- getChart(Y1,  H1, Y0,
side, FAP0,
Y2, H2, tt, TT1, bset1)
out2 <- getChart(Y1, H1, Y0,
side, FAP0,
Y2, H2, tt, TT1, bset2)
out3 <- getChart(Y1, H1, Y0,
side, FAP0,
Y2, H2, tt, TT1, bset3)
out4 <- getChart(Y1, H1, Y0,
side, FAP0,
Y2, H2, tt, TT1, bset4)
out5 <- getChart(Y1, H1, Y0,
side, FAP0,
Y2, H2, tt, TT1, bset5)
out6 <- getChart(Y1, H1, Y0,
side, FAP0,
Y2, H2, tt, TT1, bset6)
out <- c(out1, out2, out3, out4, out5, out6)
cat("Gibbs Done at X:", X, "\n")
tmp <- try(forecast::auto.arima(Y1), silent = TRUE)
if (class(tmp)[1] != "try-error") {
ph1 <- tmp$fitted
ph1[which(ph1 < 0)] <- 0
RMSE.ph1.arima <- sqrt(mean(((Y1 - ph1)^2)))
ph2 <- forecast::forecast(tmp, h = length(Y2))$mean
ph2[which(ph2 < 0)] <- 0
RMSE.ph2.arima <- sqrt(mean((Y2 - ph2) ^ 2))
}
out <- c(out, RMSE.ph1.arima, RMSE.ph2.arima)
#tmpaddr <- paste('C:/Users/yyao17/Box/2023 Summer/BayesianMonitoring/untitled folder/tmp1/sim', X, ".Rdat", sep = "")
#save(out, file = tmpaddr)
cat("end at X:", X, "\n")
return(out)
}
wrap <- function(X, pars, alpha, lambda, pi, seed = 12345) {
out <- try(simulation.wrap(X, pars, alpha, lambda, pi, seed), silent = TRUE)
return(out)
}
library(parallel)
seed <- 12345
alpha <- c(0.03083069, 0.06242601, 0.09120189)
lambda <- 0.239385
pi <- 0.1453097
nnsim <- 100
TT1 <- c(92, 183)
#TT1 <- c(92)
TT2 <- 365
w <- c(1, 3, 7)
#w <- 7
q <- 5
delta <- c(0, 0.5, 1)
tt <- 0.8
Y.hat.method <- c("median")
side <- "right-sided"
FAP0 <- 0.2
log <- c(FALSE)
sta <- c(FALSE)
pars <- expand.grid(TT1, TT2, w, q, delta, tt, Y.hat.method, side, FAP0, log, sta, 1:nnsim)
pars <- pars[1:3, ]
tt <- dim(pars)[1]
#cl <- makeCluster(min(tt, ceiling(detectCores() * 0.875)), outfile = "C:/Users/yyao17/Box/2023 Summer/BayesianMonitoring/untitled folder/tmp1/sim.log")
cl <- makeCluster(min(tt, ceiling(detectCores() * 0.875)))
clusterEvalQ(cl, library(BayesianLASSOMonitoring))
clusterEvalQ(cl, library(forecast))
clusterExport(cl, c("wrap", "simulation.wrap", "getChart"))
out <- parLapplyLB(cl, 1:tt, wrap, pars = pars, alpha = alpha, lambda = lambda, pi = pi, seed = seed)
remove.packages("BayesianLASSOMonitoring")
