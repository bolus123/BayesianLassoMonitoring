set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
Xf1 <- BayesianLASSOMonitoring::getXSeasonalityFS(w + TT1 + TT2 + 5000, 7, 2)
Xf2 <- BayesianLASSOMonitoring::getXSeasonalityFS(w + TT1 + TT2 + 5000, 30.4375, 5)
tmpdate <- as.Date("2017-01-01") + (-w + 1):(TT1 + TT2 + 5000)
businessday <- tis::isBusinessDay(tmpdate)
holiday <- tis::isHoliday(tmpdate)
Xreg <- cbind(Xf1, Xf2, businessday, holiday)
Xreg1 <- Xreg[1:(TT1 + TT2 + w - 1), ]
Y <- BayesianLASSOMonitoring::rarma(object, xreg = Xreg1, n = TT1 + TT2 + w - 1, h = ceiling(TT1 * tt) + w - 1, delta = delta)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
#H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
#H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
#H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H1 <- H1[, seq(2, TT1 - q, 7)]
H1 <- H1[, which(colSums(H1) >= 7)]
H2<- matrix(1, nrow = TT2, ncol = dim(H1)[2])
H2sim <- matrix(1, nrow = 5000, ncol = dim(H1)[2])
XX <- as.matrix(1:(TT1 + TT2 + 5000))
X1 <- as.matrix(XX[1:TT1, ])
X2 <- as.matrix(XX[(TT1 + 1):(TT1 + TT2), ])
X2sim <- as.matrix(XX[(TT1 + 1):(TT1 + 5000), ])
X1 <- cbind(X1, Xreg[1:TT1, ])
X2 <- cbind(X2, Xreg[(TT1 + 1):(TT1 + TT2), ])
bset <- list(
"method" = "regression",
"mono" = 0,
"q" = 5,
"A" = diag(rep(1, 5), nrow = 5),
"bound0" = Inf,
"boundqplus1" = 0,
"xi2" = 0.1,
"theta1" = 1,
"theta2" = 1,
"a" = 1,
"b" = 1,
"alpha" = 1,
"beta" = 1,
"updateYJ" = 1,
"leftcensoring" = 1,
"rounding" = 0,
"lambda2" = NULL,
"theta" = 1,
"eps" = 1e-32,
"nsim" = 300,
"thin" = 10,
"burnin" = 2000
)
##############################################
bb <- BayesianLASSOMonitoring::GibbsRFLSMXYJZ(as.matrix(Y1), bset, X1, H1)
debug(BayesianLASSOMonitoring::Ph1MultipleTesting.Y01L1CUMSUM)
cc0 <- BayesianLASSOMonitoring::Ph1MultipleTesting.Y01L1CUMSUM(bb, w = 14, FAP0 = 0.05, side = "right-sided",
updateYJ = 1, leftcensoring = 1, rounding = 0, eps = 1e-32,
backtr = 1, nsim = 100000, interval = c(0.000001, 0.499999), verbose = 0)
ss
dd
rowMeans(ss)
rowMeans(dd)
plot(rowMeans(dd))
Mu0
plot(Mu0)
plot(rowMeans(dd))
dd
rowMeans(dd)
dd
dim(dd)
remove.packages("BayesianLASSOMonitoring")
devtools::install_github("bolus123/BayesianLASSOMonitoring", "with-transformation")
seed <- 12345
load(file = "C:/Users/bolus/Box/2024 Spring/Temporal and Geographical Project for Opioid-overdose ER vistis/dataset/walker_OXYCODONE_model2.Rdat")
object <- walker_OXYCODONE_model2
nnsim <- 100
TT1 <- c(92, 183)
TT2 <- 365
w <- c(1)
#w <- 7
q <- 5
delta <- c(0, 1)
tt <- 0.5
Y.hat.method <- c("median")
side <- "right-sided"
FAP0 <- 0.2
log <- c(FALSE)
sta <- c(FALSE)
pars <- expand.grid(TT1, TT2, w, q, delta, tt, Y.hat.method, side, FAP0, log, sta, 1:nnsim)
X <- 4
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
Xf1 <- BayesianLASSOMonitoring::getXSeasonalityFS(w + TT1 + TT2 + 5000, 7, 2)
Xf2 <- BayesianLASSOMonitoring::getXSeasonalityFS(w + TT1 + TT2 + 5000, 30.4375, 5)
tmpdate <- as.Date("2017-01-01") + (-w + 1):(TT1 + TT2 + 5000)
businessday <- tis::isBusinessDay(tmpdate)
holiday <- tis::isHoliday(tmpdate)
Xreg <- cbind(Xf1, Xf2, businessday, holiday)
Xreg1 <- Xreg[1:(TT1 + TT2 + w - 1), ]
Y <- BayesianLASSOMonitoring::rarma(object, xreg = Xreg1, n = TT1 + TT2 + w - 1, h = ceiling(TT1 * tt) + w - 1, delta = delta)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
#H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
#H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
#H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H1 <- H1[, seq(2, TT1 - q, 7)]
H1 <- H1[, which(colSums(H1) >= 7)]
H2<- matrix(1, nrow = TT2, ncol = dim(H1)[2])
H2sim <- matrix(1, nrow = 5000, ncol = dim(H1)[2])
XX <- as.matrix(1:(TT1 + TT2 + 5000))
X1 <- as.matrix(XX[1:TT1, ])
X2 <- as.matrix(XX[(TT1 + 1):(TT1 + TT2), ])
X2sim <- as.matrix(XX[(TT1 + 1):(TT1 + 5000), ])
X1 <- cbind(X1, Xreg[1:TT1, ])
X2 <- cbind(X2, Xreg[(TT1 + 1):(TT1 + TT2), ])
bset <- list(
"method" = "regression",
"mono" = 0,
"q" = 5,
"A" = diag(rep(1, 5), nrow = 5),
"bound0" = Inf,
"boundqplus1" = 0,
"xi2" = 0.1,
"theta1" = 1,
"theta2" = 1,
"a" = 1,
"b" = 1,
"alpha" = 1,
"beta" = 1,
"updateYJ" = 1,
"leftcensoring" = 1,
"rounding" = 0,
"lambda2" = NULL,
"theta" = 1,
"eps" = 1e-32,
"nsim" = 300,
"thin" = 10,
"burnin" = 2000
)
##############################################
bb <- BayesianLASSOMonitoring::GibbsRFLSMXYJZ(as.matrix(Y1), bset, X1, H1)
debug(BayesianLASSOMonitoring::Ph1MultipleTesting.Y01L1CUMSUM)
cc0 <- BayesianLASSOMonitoring::Ph1MultipleTesting.Y01L1CUMSUM(bb, w = 14, FAP0 = 0.05, side = "right-sided",
updateYJ = 1, leftcensoring = 1, rounding = 0, eps = 1e-32,
backtr = 1, nsim = 100000, interval = c(0.000001, 0.499999), verbose = 0)
dim(dd)
rowMeans(dd)
plot(rowMeans(dd))
sig
points(cs)
sig
sig
length(cs)
cs[165]
dim(dd)
quantile(dd[165, ], 0.95)
apply(dd, 1, median)
plot(apply(dd, 1, median))
points(cs)
dd[168, ]
dim(dd)
dd[165, ]
hist(dd[165, ])
quantile(dd[165, ], 0.95)
cs
plot(model$Y)
dim(plot(model$Y))
length(plot(model$Y))
length(model$Y)
plot(c(1, 178), c(min(model$Y, ph1mat), max(model$Y, ph1mat)), type = 'n')
for (i in 1:10000) {
points(ph1mat[, i], col = 'grey')
}
plot(c(1, 178), c(min(model$Y, ph1mat), max(model$Y, ph1mat)), type = 'n')
bb
cc
cc0
cc0$adj.alpha
plot(c(1, 178), c(min(bb$Y, cc0$Yph1), max(bb$Y, cc0$Yph1)), type = 'n')
for (i in 1:10000) {
points(cc0$Yph1[, i], col = 'grey')
}
points(bb$Y[-c(1:5)])
seed <- 12345
#load(file = "C:/Users/yyao17/Box/2024 Spring/Temporal and Geographical Project for Opioid-overdose ER vistis/dataset/walker_OXYCODONE_model2.Rdat")
#load(file = "C:/Users/bolus/Box/2023 Summer/BayesianMonitoring/dataset/walker_BUPRENORPHINE_model.Rdat")
#load(file = "C:/Users/bolus/Box/2024 Spring/Temporal and Geographical Project for Opioid-overdose ER vistis/dataset/walker_OXYCODONE_model2.Rdat")
load(file = "/Users/yuihuiyao/Library/CloudStorage/Box-Box/2024 Spring/Temporal and Geographical Project for Opioid-overdose ER vistis/dataset/walker_OXYCODONE_model2.Rdat")
object <- walker_OXYCODONE_model2
nnsim <- 100
TT1 <- c(92, 183)
TT2 <- 365
w <- c(1)
#w <- 7
q <- 5
delta <- c(0, 1)
tt <- 0.5
Y.hat.method <- c("median")
side <- "right-sided"
FAP0 <- 0.2
log <- c(FALSE)
sta <- c(FALSE)
pars <- expand.grid(TT1, TT2, w, q, delta, tt, Y.hat.method, side, FAP0, log, sta, 1:nnsim)
X <- 4
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
Xf1 <- BayesianLASSOMonitoring::getXSeasonalityFS(w + TT1 + TT2 + 5000, 7, 2)
Xf2 <- BayesianLASSOMonitoring::getXSeasonalityFS(w + TT1 + TT2 + 5000, 30.4375, 5)
tmpdate <- as.Date("2017-01-01") + (-w + 1):(TT1 + TT2 + 5000)
businessday <- tis::isBusinessDay(tmpdate)
holiday <- tis::isHoliday(tmpdate)
Xreg <- cbind(Xf1, Xf2, businessday, holiday)
Xreg1 <- Xreg[1:(TT1 + TT2 + w - 1), ]
Y <- BayesianLASSOMonitoring::rarma(object, xreg = Xreg1, n = TT1 + TT2 + w - 1, h = ceiling(TT1 * tt) + w - 1, delta = delta)
Y0 <- Y[1:(w - 1)]
Y1 <- Y[w:(TT1 + w - 1)]
Y2 <- Y[(TT1 + w):(TT1 + TT2 + w - 1)]
#H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
#H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
#H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
H1 <- H1[, seq(2, TT1 - q, 7)]
H1 <- H1[, which(colSums(H1) >= 7)]
H2<- matrix(1, nrow = TT2, ncol = dim(H1)[2])
H2sim <- matrix(1, nrow = 5000, ncol = dim(H1)[2])
XX <- as.matrix(1:(TT1 + TT2 + 5000))
X1 <- as.matrix(XX[1:TT1, ])
X2 <- as.matrix(XX[(TT1 + 1):(TT1 + TT2), ])
X2sim <- as.matrix(XX[(TT1 + 1):(TT1 + 5000), ])
X1 <- cbind(X1, Xreg[1:TT1, ])
X2 <- cbind(X2, Xreg[(TT1 + 1):(TT1 + TT2), ])
bset <- list(
"method" = "ALASSO",
"mono" = 1,
"q" = 5,
"A" = diag(rep(1, 5), nrow = 5),
"bound0" = Inf,
"boundqplus1" = 0,
"xi2" = 0.1,
"theta1" = 1,
"theta2" = 1,
"a" = 1,
"b" = 1,
"alpha" = 1,
"beta" = 1,
"updateYJ" = 1,
"leftcensoring" = 1,
"rounding" = 0,
"lambda2" = NULL,
"theta" = 1,
"eps" = 1e-32,
"nsim" = 300,
"thin" = 10,
"burnin" = 2000
)
##############################################
bb <- BayesianLASSOMonitoring::GibbsRFLSMXYJZ(as.matrix(Y1), bset, X1, H1)
cc0 <- BayesianLASSOMonitoring::Ph1MultipleTesting.Y01L1(bb, w = 14, FAP0 = 0.05, side = "right-sided",
updateYJ = 1, leftcensoring = 1, rounding = 0, eps = 1e-32,
backtr = 1, nsim = 100000, interval = c(0.000001, 0.499999), verbose = 0)
cc0$grandsig
cc0$cs
cc0$sig
plot(c(1, 178), c(min(bb$Y, cc0$Yph1), max(bb$Y, cc0$Yph1)), type = 'n')
for (i in 1:1000) {
points(cc0$Yph1[, i], col = 'grey')
}
points(bb$Y[-c(1:5)])
X1
rowMeans(bb$Beta * bb$Zeta)
rowMeans(bb$Tau * bb$Gamma)
ee <- apply(bb$Gamma * bb$Tau, 1, median)
ee
ee <- rowMeans((bb$Gamma * bb$Tau) > 0)
ee
ee <- rowMeans((bb$Gamma * bb$Tau) >< 0)
ee <- rowMeans((bb$Gamma * bb$Tau) < 0)
ee <- rowMeans((bb$Gamma * bb$Tau) != 0)
ee
ee0 <- abs(bb$Gamma * bb$Tau)
dim(ee0)
ee0 <- colMeans(abs(bb$Gamma * bb$Tau))
ee <- apply(bb$Gamma * bb$Tau, 1, median)
ee
ee0
ee0 <- rowMeans(abs(bb$Gamma * bb$Tau))
ee0
ee <- apply(bb$Gamma * bb$Tau, 1, median) / ee0
ee
ee0
VGAM::plaplace(ee, 0, 1)
p.adjust(1 - VGAM::plaplace(ee, 0, 1))
1 - VGAM::plaplace(ee, 0, 1)
ee0 <- rowMeans(abs(bb$H%*% (bb$Gamma * bb$Tau)))
ee0
ee0
ee <- apply(bb$H%*% (bb$Gamma * bb$Tau), 1, median) / ee0
ee
plot(ee)
diff(ee)
plot(diff(ee))
diff(bb$H%*% (bb$Gamma * bb$Tau))
ee <- bb$H%*% (bb$Gamma * bb$Tau)
ee0 <- plot(diff(ee))
ee0
ee <- bb$H%*% (bb$Gamma * bb$Tau)
ee0 <- diff(ee)
ee0
(bb$Gamma * bb$Tau) / rowMeans((bb$Gamma * bb$Tau))
(bb$Gamma * bb$Tau) / apply((bb$Gamma * bb$Tau), 1, sd)
plot((bb$Gamma * bb$Tau) / apply((bb$Gamma * bb$Tau), 1, sd))
(bb$Gamma * bb$Tau) / apply((bb$Gamma * bb$Tau), 1, sd)
(rowMeans(bb$Gamma * bb$Tau)) / apply((bb$Gamma * bb$Tau), 1, sd)
plot((rowMeans(bb$Gamma * bb$Tau)) / apply((bb$Gamma * bb$Tau), 1, sd))
plot(pnorm((rowMeans(bb$Gamma * bb$Tau)) / apply((bb$Gamma * bb$Tau), 1, sd)))
plot(pnorm((rowMeans(bb$Gamma * bb$Tau)) / apply((bb$Gamma * bb$Tau), 1, sd)))
aaa <- pnorm((rowMeans(bb$Gamma * bb$Tau)) / apply((bb$Gamma * bb$Tau), 1, sd))
aaa
1 - (1 - 0.05)^(1/25)
dim
(bb$H)
dim(bb$H)
bb$H %*% (rep(0, 25))
bb$H %*% (rep(0, 25))
aaa
1 - (1 - 0.05)^(1/25)
aaa > (1-1 - (1 - 0.05)^(1/25))
(1 - aaa) > (1 - (1 - 0.05)^(1/25))
1 - (1 - 0.05)^(1/25)
(1 - aaa) <= (1 - (1 - 0.05)^(1/25))
(1 - aaa) > (1 - (1 - 0.05)^(1/25))
bb$H %*% ((1 - aaa) > (1 - (1 - 0.05)^(1/25)))
(1 - aaa) > (1 - (1 - 0.05)^(1/25))
(1 - aaa) < (1 - (1 - 0.05)^(1/25))
(1 - aaa) <= (1 - (1 - 0.05)^(1/25))
bb$H %*% ((1 - aaa) <= (1 - (1 - 0.05)^(1/25)))
183 * tt
?palette.colors
hcl.colors
?hcl.colors
hcl.colors(n = 10, "Dark Mint")
hcl.colors(n = 10, "TealGm")
hcl.colors(n = 10, "ag_GrnYl")
hcl.colors(n = 10, "Teal")
bb$Tau * bb$Gamma
plot((bb$Tau * bb$Gamma)[1, ])
plot((bb$Tau * bb$Gamma)[2, ])
acf((bb$Tau * bb$Gamma)[1, ])
acf((bb$Tau * bb$Gamma)[2, ])
Ph1MultipleTesting.GammaBC <- function(model, w = 7, FAP0 = 0.2, side = "right-sided") {
n <- legnth(model$Y)
q <- dim(model$Phi)[2]
grand.sig <- 0
sig <- rep(0, n)
pvalue <- rep(NA, n)
if (!is.null(model$H)) {
m <- dim(model$H)[2]
TauGamma <- model$H %*% (model$Tau * model$Gamma)
cs <- rowMeans(TauGamma) / apply(TauGamma, 1, sd)
if (side == "right-sided") {
pvalue <- 1 - pnorm(cs)
} else if (side == "left-sided") {
pvalue <- pnorm(cs)
} else {
pvalue1 <- 1 - pnorm(cs)
pvalue2 <- pnorm(cs)
pvalue <- cbind(pvalue1, pvalue2)
pvalue <- apply(pvalue, 1, min)
pvalue <- pvalue * 2
}
adj.alpha <- 1 - (1 - FAP0) ^ (1 / m) #sidak
sig <- pvalue <= adj.alpha
grand.sig <- sum(sig) > 0
}
list("grandsig" = grand.sig, "cs" = cs, "sig" = sig, "lim" = lim, "pvalue" = pvalue, "adj.alpha" = adj.alpha)
}
Ph1MultipleTesting.GammaBC(bb)
Ph1MultipleTesting.GammaBC <- function(model, w = 7, FAP0 = 0.2, side = "right-sided") {
n <- length(model$Y)
q <- dim(model$Phi)[2]
grand.sig <- 0
sig <- rep(0, n)
pvalue <- rep(NA, n)
if (!is.null(model$H)) {
m <- dim(model$H)[2]
TauGamma <- model$H %*% (model$Tau * model$Gamma)
cs <- rowMeans(TauGamma) / apply(TauGamma, 1, sd)
if (side == "right-sided") {
pvalue <- 1 - pnorm(cs)
} else if (side == "left-sided") {
pvalue <- pnorm(cs)
} else {
pvalue1 <- 1 - pnorm(cs)
pvalue2 <- pnorm(cs)
pvalue <- cbind(pvalue1, pvalue2)
pvalue <- apply(pvalue, 1, min)
pvalue <- pvalue * 2
}
adj.alpha <- 1 - (1 - FAP0) ^ (1 / m) #sidak
sig <- pvalue <= adj.alpha
grand.sig <- sum(sig) > 0
}
list("grandsig" = grand.sig, "cs" = cs, "sig" = sig, "lim" = lim, "pvalue" = pvalue, "adj.alpha" = adj.alpha)
}
Ph1MultipleTesting.GammaBC(bb)
Ph1MultipleTesting.GammaBC <- function(model, w = 7, FAP0 = 0.2, side = "right-sided") {
n <- length(model$Y)
q <- dim(model$Phi)[2]
grand.sig <- 0
sig <- 0
pvalue <- NULL
lim <- NULL
if (!is.null(model$H)) {
m <- dim(model$H)[2]
sig <- rep(0, m)
pvalue <- rep(NA, m)
lim <- cbind(rep(-Inf, m), rep(Inf, m))
TauGamma <- (model$Tau * model$Gamma)
cs <- rowMeans(TauGamma) / apply(TauGamma, 1, sd)
adj.alpha <- 1 - (1 - FAP0) ^ (1 / m) #sidak
if (side == "right-sided") {
pvalue <- 1 - pnorm(cs)
} else if (side == "left-sided") {
pvalue <- pnorm(cs)
} else {
pvalue1 <- 1 - pnorm(cs)
pvalue2 <- pnorm(cs)
pvalue <- cbind(pvalue1, pvalue2)
pvalue <- apply(pvalue, 1, min)
pvalue <- pvalue * 2
}
sig <- pvalue <= adj.alpha
grand.sig <- sum(sig) > 0
}
list("grandsig" = grand.sig, "cs" = cs, "sig" = sig, "lim" = lim, "pvalue" = pvalue, "adj.alpha" = adj.alpha)
}
Ph1MultipleTesting.GammaBC(bb)
bb$H %*% (bb$Gamma * bb$Tau)
rowMeans(bb$H %*% (bb$Gamma * bb$Tau))
rowMeans(bb$H %*% (bb$Gamma * bb$Tau)) / apply(bb$H %*% (bb$Gamma * bb$Tau), 1, sd)
plot(rowMeans(bb$H %*% (bb$Gamma * bb$Tau)) / apply(bb$H %*% (bb$Gamma * bb$Tau), 1, sd))
Ph1MultipleTesting.GammaBC(bb)
Ph1MultipleTesting.GammaBC <- function(model, w = 7, FAP0 = 0.2, side = "right-sided") {
n <- length(model$Y)
q <- dim(model$Phi)[2]
grand.sig <- 0
sig <- 0
pvalue <- NULL
lim <- NULL
if (!is.null(model$H)) {
m <- dim(model$H)[2]
sig <- rep(0, m)
pvalue <- rep(NA, m)
lim <- cbind(rep(-Inf, m), rep(Inf, m))
TauGamma <- (model$Tau * model$Gamma)
cs <- rowMeans(TauGamma) / apply(TauGamma, 1, sd)
adj.alpha <- 1 - (1 - FAP0) ^ (1 / m) #sidak
if (side == "right-sided") {
pvalue <- 1 - pnorm(cs)
} else if (side == "left-sided") {
pvalue <- pnorm(cs)
} else {
pvalue1 <- 1 - pnorm(cs)
pvalue2 <- pnorm(cs)
pvalue <- cbind(pvalue1, pvalue2)
pvalue <- apply(pvalue, 1, min)
pvalue <- pvalue * 2
}
sig <- pvalue <= adj.alpha
grand.sig <- sum(sig) > 0
}
list("grandsig" = grand.sig, "cs" = cs, "sig" = sig, "pvalue" = pvalue, "adj.alpha" = adj.alpha)
}
Ph1MultipleTesting.GammaBC(bb, side = "two-sided")
Ph1MultipleTesting.GammaBC(bb, side = "left-sided")
13 * 7
(13 * 7):(13 * 8)
(13 * 7):(14 * 7)
Rcpp::compileAttributes()
roxygen2::roxygenise()
remove.packages("BayesianLASSOMonitoring")
