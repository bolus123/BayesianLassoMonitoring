bset1$adjZ, bset1$Zlb, bset1$Zub, bset1$eta2,
1000, 10, 300,
1e-32, NULL, NULL,X1, H1)
qq$Z
qq$Z[1, ]
hist(qq$Z[1, ])
hist(qq$Z[2, ])
hist(qq$Z[3, ])
hist(qq$Z[4, ])
hist(qq$Z[5, ])
hist(qq$Z[6, ])
hist(qq$Z[7, ])
hist(qq$Z[8, ])
qq$theta
qq$eta2
remove.packages("BayesianLASSOMonitoring")
?p.adjust
#' Bayesian LASSO Phase I Monitoring
#'
#' gets a posterior sample using Gibbs sampling for Random Flexible Level Shift Model
#' @param model is model.
#' @param nsim is .
#' @param FAP0 is
#' @param log is model.
#' @param const is .
#' @param sta is
#'
#'
#' @export
Ph1MultipleTesting.GammaNormCUMSUMBC <- function(model, w = 7, FAP0 = 0.05, method = "bonferroni", side = "right-sided") {
n <- length(model$Y)
q <- dim(model$Phi)[2]
grand.sig <- 0
sig <- 0
pvalue <- NULL
lim <- NULL
if (!is.null(model$H)) {
m <- dim(model$H)[2]
sig <- rep(0, m)
pvalue <- rep(NA, m)
lim <- cbind(rep(-Inf, m), rep(Inf, m))
TauGamma <- model$H %*% (model$Tau * model$Gamma)
ss <- apply(TauGamma, 1, sd)
cs <- rowMeans(TauGamma) / ss
cs[which(is.na(cs) & (ss == 0))] <- 0
#adj.alpha <- FAP0 / m #BC
#adj.alpha <- 1 - (1 - FAP0) ^ (1 / m) #sidak
if (side == "right-sided") {
pvalue <- 1 - pnorm(cs)
} else if (side == "left-sided") {
pvalue <- pnorm(cs)
} else {
pvalue1 <- 1 - pnorm(cs)
pvalue2 <- pnorm(cs)
pvalue <- cbind(pvalue1, pvalue2)
pvalue <- apply(pvalue, 1, min)
pvalue <- pvalue * 2
}
#sig <- pvalue <= adj.alpha
#grand.sig <- sum(sig) > 0
}
adj.alpha <- p.adjust(pvalue, method)
sig <- adj.alpha <= FAP0
grand.sig <- sum(sig) > 0
tmpsig <- sig#model$H %*% sig
tmpsig[tmpsig > 1] <- 1
tmpsig[tmpsig < 0] <- 0
tmpsig <- diff(tmpsig)
tmpsig <- c(0, tmpsig)
tmpsel <- which(tmpsig == 1)
nsel <- length(tmpsel)
if (nsel > 0) {
for (i in 1:nsel) {
tmpsig[tmpsel[i]:(tmpsel[i] + w - 1)] <- 1
}
}
list("grandsig" = grand.sig, "cs" = cs,
"sig" = tmpsig,
"parsig" = sig,
"pvalue" = pvalue, "adj.alpha" = adj.alpha)
}
Ph1MultipleTesting.GammaNormCUMSUMBC <- function(model, w = 7, FAP0 = 0.05, method = "BY", side = "right-sided") {
n <- length(model$Y)
q <- dim(model$Phi)[2]
grand.sig <- 0
sig <- 0
pvalue <- NULL
lim <- NULL
if (!is.null(model$H)) {
m <- dim(model$H)[2]
sig <- rep(0, m)
pvalue <- rep(NA, m)
lim <- cbind(rep(-Inf, m), rep(Inf, m))
TauGamma <- model$H %*% (model$Tau * model$Gamma)
ss <- apply(TauGamma, 1, sd)
cs <- rowMeans(TauGamma) / ss
cs[which(is.na(cs) & (ss == 0))] <- 0
#adj.alpha <- FAP0 / m #BC
#adj.alpha <- 1 - (1 - FAP0) ^ (1 / m) #sidak
if (side == "right-sided") {
pvalue <- 1 - pnorm(cs)
} else if (side == "left-sided") {
pvalue <- pnorm(cs)
} else {
pvalue1 <- 1 - pnorm(cs)
pvalue2 <- pnorm(cs)
pvalue <- cbind(pvalue1, pvalue2)
pvalue <- apply(pvalue, 1, min)
pvalue <- pvalue * 2
}
#sig <- pvalue <= adj.alpha
#grand.sig <- sum(sig) > 0
}
adj.alpha <- p.adjust(pvalue, method)
sig <- adj.alpha <= FAP0
grand.sig <- sum(sig) > 0
tmpsig <- sig#model$H %*% sig
tmpsig[tmpsig > 1] <- 1
tmpsig[tmpsig < 0] <- 0
tmpsig <- diff(tmpsig)
tmpsig <- c(0, tmpsig)
tmpsel <- which(tmpsig == 1)
nsel <- length(tmpsel)
if (nsel > 0) {
for (i in 1:nsel) {
tmpsig[tmpsel[i]:(tmpsel[i] + w - 1)] <- 1
}
}
list("grandsig" = grand.sig, "cs" = cs,
"sig" = tmpsig,
"parsig" = sig,
"pvalue" = pvalue, "adj.alpha" = adj.alpha)
}
Ph1MultipleTesting.GammaNormCUMSUMBC <- function(model, w = 7, FAP0 = 0.05, method = "BY", side = "right-sided") {
n <- length(model$Y)
q <- dim(model$Phi)[2]
grand.sig <- 0
sig <- 0
pvalue <- NULL
lim <- NULL
if (!is.null(model$H)) {
m <- dim(model$H)[2]
sig <- rep(0, m)
pvalue <- rep(NA, m)
lim <- cbind(rep(-Inf, m), rep(Inf, m))
TauGamma <- model$H %*% (model$Tau * model$Gamma)
ss <- apply(TauGamma, 1, sd)
cs <- rowMeans(TauGamma) / ss
cs[which(is.na(cs) & (ss == 0))] <- 0
#adj.alpha <- FAP0 / m #BC
#adj.alpha <- 1 - (1 - FAP0) ^ (1 / m) #sidak
if (side == "right-sided") {
pvalue <- 1 - pnorm(cs)
} else if (side == "left-sided") {
pvalue <- pnorm(cs)
} else {
pvalue1 <- 1 - pnorm(cs)
pvalue2 <- pnorm(cs)
pvalue <- cbind(pvalue1, pvalue2)
pvalue <- apply(pvalue, 1, min)
pvalue <- pvalue * 2
}
#sig <- pvalue <= adj.alpha
#grand.sig <- sum(sig) > 0
}
adj.alpha <- p.adjust(pvalue, method)
sig <- adj.alpha <= FAP0
grand.sig <- sum(sig) > 0
tmpsig <- sig#model$H %*% sig
tmpsig[tmpsig > 1] <- 1
tmpsig[tmpsig < 0] <- 0
tmpsig <- diff(tmpsig)
tmpsig <- c(0, tmpsig)
tmpsel <- which(tmpsig == 1)
nsel <- length(tmpsel)
if (nsel > 0) {
for (i in 1:nsel) {
tmpsig[tmpsel[i]:(tmpsel[i] + w - 1)] <- 1
}
}
list("grandsig" = grand.sig, "cs" = cs,
"sig" = tmpsig,
"parsig" = sig,
"pvalue" = pvalue, "adj.pvalue" = adj.alpha)
}
load(file = 'C:/Users/bolus/Box/2024 Spring/Temporal and Geographical Project for Opioid-overdose ER vistis/dataset/presentation/walker_OXYCODONE_modelB2.Rdat')
aa1 <- Ph1MultipleTesting.GammaNormCUMSUMBC(modelB2, w = 7, FAP0 = 0.05, method = "BY", side = "right-sided")
aa1
aa1 <- Ph1MultipleTesting.GammaNormCUMSUMBC(modelB2, w = 7, FAP0 = 0.05, method = "holm", side = "right-sided")
aa2 <- Ph1MultipleTesting.GammaNormCUMSUMBC(modelB2, w = 7, FAP0 = 0.05, method = "hommel", side = "right-sided")
aa3 <- Ph1MultipleTesting.GammaNormCUMSUMBC(modelB2, w = 7, FAP0 = 0.05, method = "BY", side = "right-sided")
aa1
aa2
aa3
load(file = 'C:/Users/bolus/Box/2024 Spring/Temporal and Geographical Project for Opioid-overdose ER vistis/dataset/presentation/walker_BUPRENORPHINE_modelB2.Rdat')
aa1 <- Ph1MultipleTesting.GammaNormCUMSUMBC(modelB2, w = 7, FAP0 = 0.05, method = "holm", side = "right-sided")
aa2 <- Ph1MultipleTesting.GammaNormCUMSUMBC(modelB2, w = 7, FAP0 = 0.05, method = "hommel", side = "right-sided")
aa3 <- Ph1MultipleTesting.GammaNormCUMSUMBC(modelB2, w = 7, FAP0 = 0.05, method = "BY", side = "right-sided")
aa1
aa2
aa3
plot(aa1$adj.pvalue)
plot(aa2$adj.pvalue)
plot(aa3$adj.pvalue)
load(file = 'C:/Users/bolus/Box/2024 Spring/Temporal and Geographical Project for Opioid-overdose ER vistis/dataset/presentation/walker_ER_modelB2.Rdat')
aa1 <- Ph1MultipleTesting.GammaNormCUMSUMBC(modelB2, w = 7, FAP0 = 0.05, method = "holm", side = "right-sided")
aa2 <- Ph1MultipleTesting.GammaNormCUMSUMBC(modelB2, w = 7, FAP0 = 0.05, method = "hommel", side = "right-sided")
aa3 <- Ph1MultipleTesting.GammaNormCUMSUMBC(modelB2, w = 7, FAP0 = 0.05, method = "BY", side = "right-sided")
aa1
aa2
aa3
load(file = 'C:/Users/bolus/Box/2024 Spring/Temporal and Geographical Project for Opioid-overdose ER vistis/dataset/presentation/walker_BUPRENORPHINE_modelB2.Rdat')
aa1 <- Ph1MultipleTesting.GammaNormCUMSUMBC(modelB2, w = 7, FAP0 = 0.05, method = "holm", side = "right-sided")
aa2 <- Ph1MultipleTesting.GammaNormCUMSUMBC(modelB2, w = 7, FAP0 = 0.05, method = "hommel", side = "right-sided")
aa3 <- Ph1MultipleTesting.GammaNormCUMSUMBC(modelB2, w = 7, FAP0 = 0.05, method = "BY", side = "right-sided")
aa1
debug(Ph1MultipleTesting.GammaNormCUMSUMBC)
aa1 <- Ph1MultipleTesting.GammaNormCUMSUMBC(modelB2, w = 7, FAP0 = 0.05, method = "holm", side = "right-sided")
plot(cs)
hist(TauGamma[1, ])
hist(TauGamma[100, ])
hist(TauGamma[300, ])
hist(TauGamma[400, ])
hist(TauGamma[500, ])
hist(TauGamma[600, ])
hist(TauGamma[700, ])
hist(TauGamma[800, ])
hist(TauGamma[800, ])
Rcpp::compileAttributes()
roxygen2::roxygenize()
roxygen2::roxygenize()
Rcpp::compileAttributes()
roxygen2::roxygenise()
Rcpp::compileAttributes()
roxygen2::roxygenise()
remove.packages("BayesianLASSOMonitoring")
devtools::install_github("bolus123/BayesianLASSOMonitoring", "with-transformation")
##############################################
# Matrix form
##############################################
invert.q <- function(coef) {
out <- 1
if (all(abs(coef) < 1)) {
minmod <- min(Mod(polyroot(c(1, coef))))
if (minmod <= 1) {
out <- 0
}
} else {
out <- 0
}
return(out)
}
pars.mat <- function(n, parsVec, norder = 1) {
Check <- invert.q(parsVec)
if (Check == 0) {
NULL
} else {
Mat <- diag(n)
for (i in 1:norder) {
Mat <- Mat + Diag(rep(parsVec[i], n - i), k = -i)
}
Mat
}
}
#' simulate realizations using INAR(3) with zero-inflated Poisson innovation and one sustained shift
#'
#' @param n is the length
#' @param alpha is the alpha
#' @param lambda is the mean of poisson mixture
#' @param pi is the proportion of zeros
#' @param h is the start point of shift
#' @param delta is the value of the standardized shift
#' @param burnin is the length of the burn-in period
#' @export
#' @examples
#' nsim <- 100
#' burnin <- 100
#' T <- 100
#' q <- 5
#' H <- getHMatMT(T, q)
#' Y <- arima.sim(list(ar = 0.5), n = T)
#'
#' alpha <- c(0.03083069, 0.06242601, 0.09120189)
#' lambda <- 0.239385
#' pi <- 0.1453097
#'
#' TT <- 183
#' w <- 28
#' Y <- rzinpoisinar3(TT + w, alpha, lambda, pi, ceiling(TT / 2) + w, delta = 1, burnin = burnin)
#'
sigma.mat <- function(n, order = c(1, 0, 0), phi.vec = 0.5, theta.vec = NULL, sigma2 = 1, burn.in = 50) {
if (order[1] == 0) {
phiMat <- diag(n + burn.in)
} else {
phiMat <- pars.mat(n + burn.in, -phi.vec, norder = order[1])
}
if (order[3] == 0) {
thetaMat <- diag(n + burn.in)
} else {
thetaMat <- pars.mat(n + burn.in, theta.vec, norder = order[3])
}
out <- solve(phiMat) %*% thetaMat %*% t(thetaMat) %*% t(solve(phiMat)) * sigma2
gamma0 <- out[dim(out)[1], dim(out)[2]]
if (burn.in > 0) {
out <- out[-c(1:burn.in), -c(1:burn.in)]
}
list(sigma.mat = out, sqrtsigma.mat = sqrtm(out)$B, gamma0 = gamma0)
}
load(file = "C:/Users/yyao17/Box/2024 Spring/Temporal and Geographical Project for Opioid-overdose ER vistis/dataset/walker_OXYCODONE_model2.Rdat")
load(file = "C:/Users/bolus/Box/2024 Spring/Temporal and Geographical Project for Opioid-overdose ER vistis/dataset/walker_OXYCODONE_model2.Rdat")
object <- walker_OXYCODONE_model2
object$coef
names(object$coef)
substr(names(object$coef), 1, 2)
substr(names(object$coef), 1, 2) == "ar"
which(substr(names(object$coef), 1, 2) == "ar")
##############################################
# Matrix form
##############################################
invert.q <- function(coef) {
out <- 1
if (all(abs(coef) < 1)) {
minmod <- min(Mod(polyroot(c(1, coef))))
if (minmod <= 1) {
out <- 0
}
} else {
out <- 0
}
return(out)
}
pars.mat <- function(n, parsVec, norder = 1) {
Check <- invert.q(parsVec)
if (Check == 0) {
NULL
} else {
Mat <- diag(n)
for (i in 1:norder) {
Mat <- Mat + Diag(rep(parsVec[i], n - i), k = -i)
}
Mat
}
}
#' simulate realizations using INAR(3) with zero-inflated Poisson innovation and one sustained shift
#'
#' @param n is the length
#' @param alpha is the alpha
#' @param lambda is the mean of poisson mixture
#' @param pi is the proportion of zeros
#' @param h is the start point of shift
#' @param delta is the value of the standardized shift
#' @param burnin is the length of the burn-in period
#' @export
#' @examples
#' nsim <- 100
#' burnin <- 100
#' T <- 100
#' q <- 5
#' H <- getHMatMT(T, q)
#' Y <- arima.sim(list(ar = 0.5), n = T)
#'
#' alpha <- c(0.03083069, 0.06242601, 0.09120189)
#' lambda <- 0.239385
#' pi <- 0.1453097
#'
#' TT <- 183
#' w <- 28
#' Y <- rzinpoisinar3(TT + w, alpha, lambda, pi, ceiling(TT / 2) + w, delta = 1, burnin = burnin)
#'
sigma.mat <- function(n, order = c(1, 0, 0), phi.vec = 0.5, theta.vec = NULL, sigma2 = 1, burn.in = 50) {
if (order[1] == 0) {
phiMat <- diag(n + burn.in)
} else {
phiMat <- pars.mat(n + burn.in, -phi.vec, norder = order[1])
}
if (order[3] == 0) {
thetaMat <- diag(n + burn.in)
} else {
thetaMat <- pars.mat(n + burn.in, theta.vec, norder = order[3])
}
out <- solve(phiMat) %*% thetaMat %*% t(thetaMat) %*% t(solve(phiMat)) * sigma2
gamma0 <- out[dim(out)[1], dim(out)[2]]
if (burn.in > 0) {
out <- out[-c(1:burn.in), -c(1:burn.in)]
}
list(sigma.mat = out, sqrtsigma.mat = sqrtm(out)$B, gamma0 = gamma0)
}
which(substr(names(object$coef), 1, 2) == "ar")
ar <- object$coef[which(substr(names(object$coef), 1, 2) == "ar")]
ar
ma <- object$coef[which(substr(names(object$coef), 1, 2) == "ma")]
ma
##############################################
# Matrix form
##############################################
invert.q <- function(coef) {
out <- 1
if (all(abs(coef) < 1)) {
minmod <- min(Mod(polyroot(c(1, coef))))
if (minmod <= 1) {
out <- 0
}
} else {
out <- 0
}
return(out)
}
pars.mat <- function(n, parsVec, norder = 1) {
Check <- invert.q(parsVec)
if (Check == 0) {
NULL
} else {
Mat <- diag(n)
for (i in 1:norder) {
Mat <- Mat + Diag(rep(parsVec[i], n - i), k = -i)
}
Mat
}
}
#' simulate realizations using INAR(3) with zero-inflated Poisson innovation and one sustained shift
#'
#' @param n is the length
#' @param alpha is the alpha
#' @param lambda is the mean of poisson mixture
#' @param pi is the proportion of zeros
#' @param h is the start point of shift
#' @param delta is the value of the standardized shift
#' @param burnin is the length of the burn-in period
#' @export
#' @examples
#' nsim <- 100
#' burnin <- 100
#' T <- 100
#' q <- 5
#' H <- getHMatMT(T, q)
#' Y <- arima.sim(list(ar = 0.5), n = T)
#'
#' alpha <- c(0.03083069, 0.06242601, 0.09120189)
#' lambda <- 0.239385
#' pi <- 0.1453097
#'
#' TT <- 183
#' w <- 28
#' Y <- rzinpoisinar3(TT + w, alpha, lambda, pi, ceiling(TT / 2) + w, delta = 1, burnin = burnin)
#'
sigma.mat <- function(n, order = c(1, 0, 0), phi.vec = 0.5, theta.vec = NULL, sigma2 = 1, burn.in = 50) {
if (order[1] == 0) {
phiMat <- diag(n + burn.in)
} else {
phiMat <- pars.mat(n + burn.in, -phi.vec, norder = order[1])
}
if (order[3] == 0) {
thetaMat <- diag(n + burn.in)
} else {
thetaMat <- pars.mat(n + burn.in, theta.vec, norder = order[3])
}
out <- solve(phiMat) %*% thetaMat %*% t(thetaMat) %*% t(solve(phiMat)) * sigma2
gamma0 <- out[dim(out)[1], dim(out)[2]]
if (burn.in > 0) {
out <- out[-c(1:burn.in), -c(1:burn.in)]
}
list(sigma.mat = out, sqrtsigma.mat = sqrtm(out)$B, gamma0 = gamma0)
}
sigma.mat(100, order = c(5, 0, 1), phi.vec = ar, theta.vec = ma, sigma2 = object$sigma2)
library(pracma)
sigma.mat(100, order = c(5, 0, 1), phi.vec = ar, theta.vec = ma, sigma2 = object$sigma2)
object$series
object$model$phi
object$model$theta
object$model$Delta
object$model$Z
object$model$a
object$coef
length(object$model$phi != 0)
length(object$model$theta != 0)
sum(object$model$phi != 0)
sum(object$model$theta != 0)
object$model$phi[which(object$model$phi != 0)]
rarma <- function(object, n, h, delta, xreg = NULL, nsim = 100, burnin = 50, lowerbound = 0) {
order <- c(0, 0, 0)
nar <- sum(object$model$phi != 0)
nma <- sum(object$model$theta != 0)
if (nar > 0) {
order[1] <- nar
phi.vec <- object$model$phi[which(object$model$phi != 0)]
} else {
phi.vec <- NULL
}
if (nma > 0) {
order[3] <- nma
theta.vec <- object$model$phi[which(object$model$theta != 0)]
} else {
theta.vec <- NULL
}
ss <- sigma.mat(100, order = order, phi.vec = phi.vec, theta.vec = theta.vec, sigma2 = object$sigma2,
burn.in = 50)
mu <- rep(0, n)
mu[h:n] <- mu[h:n] + ss$gamma0 * delta
ts <- simulate(object, nsim = n, future = FALSE, xreg = xreg)
ts <- ts + mu
#innov <- rnorm(n, mu, sqrt(object$sigma2))
#ts <- simulate(object, nsim = n, future = FALSE, innov = innov, xreg = xreg)
ts[which(ts < lowerbound)] <- lowerbound
ts
}
rarma(object, 100, 0)
rarma(object, 100, 0, 0)
Rcpp::compileAttributes()
roxygeni
roxygen2::roxygenise()
roxygen2::roxygenise()
remove.packages("BayesianLASSOMonitoring")
