holiday <- tis::isHoliday(tmpdate)
Xreg <- cbind(Xf1, Xf2, businessday, holiday)
Xreg1 <- Xreg[1:(TT1 + TT2), ]
##debug(BayesianLASSOMonitoring::rarma)
Y <- rar(ar, TT1 + TT2, ceiling(TT1 * tt), delta, dist.innov = "gamma")
Y1 <- Y[1:(TT1)]
Y2 <- Y[(TT1 + 1):(TT1 + TT2)]
#H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
#H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
#H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
if (w > 1) {
H1 <- H1[, seq(1, TT1 - q, w)]
H1 <- H1[, -c(colSums(H1) < w)]
}
H2<- matrix(1, nrow = TT2, ncol = dim(H1)[2])
H2sim <- matrix(1, nrow = 5000, ncol = dim(H1)[2])
adjZ <- rep(0, TT1)
Zlb <- rep(0, TT1)
Zub <- rep(0, TT1)
bset1 <- list(
"method" = "MT",
"mono" = 0,
"q" = 5,
"A" = diag(rep(1, 5), nrow = 5),
"bound0" = Inf,
"boundqplus1" = 0,
"xi2" = 0.1,
"theta1" = 1,
"theta2" = 1,
"a" = 1,
"b" = 1,
"alpha" = 1,
"beta" = 1,
"updateYJ" = 1,
"adjZ" = adjZ,
"Zlb" = Zlb,
"Zub" = Zub,
"omega2" = 0.03,
"lambda2" = NULL,
"theta" = 1,
"eps" = 1e-32,
"nsim" = 300,
"thin" = 10,
"burnin" = 2000,
"leftcensoring" = 0,
"rounding" = 0
)
bset2 <- bset1
bset2$method <- "regression"
bset2$mono <- 0
bset3 <- bset1
bset3$method <- "LASSO"
bset3$mono <- 0
bset4 <- bset1
bset4$method <- "ALASSO"
bset4$mono <- 0
bset5 <- bset1
bset5$method <- "LASSO"
bset5$mono <- 1
bset6 <- bset1
bset6$method <- "ALASSO"
bset6$mono <- 1
out <-  rep(NA, 6 * 14)
out1 <- getChart(Y1,  H1, Y0,
side, FAP0,
Y2, H2, tt, TT1, X1, X2, bset1, w)
getChart <- function(Y1, H1, Y0,
side, FAP0,
Y2, H2, tt, TT1, X1, X2, bset, w) {
chart1 <- try(BayesianLASSOMonitoring::GibbsRFLSMXYJZ(as.matrix(Y1), bset, H = H1), silent = TRUE)
chart2 <- try(BayesianLASSOMonitoring::Ph1MultipleTesting.GammaNormBC(chart1, w = w, FAP0 = FAP0, method = "bonferroni", side = side), silent = TRUE)
chart3 <- try(BayesianLASSOMonitoring::Ph1MultipleTesting.GammaNormBC(chart1, w = w, FAP0 = FAP0, method = "holm", side = side), silent = TRUE)
chart4 <- try(BayesianLASSOMonitoring::Ph1MultipleTesting.GammaNormBC(chart1, w = w, FAP0 = FAP0, method = "BH", side = side), silent = TRUE)
Yph1 <- matrix(NA, nrow = length(Y1) - bset$q, ncol = 10000)
Yph2 <- matrix(NA, nrow = length(Y2), ncol = 10000)
if (class(chart1)[1] != "try-error") {
tmpMu1 <- H1 %*% (chart1$Gamma * chart1$Tau)
tmpMu2 <- H2 %*% (chart1$Gamma * chart1$Tau)
tmpMu2 <- rbind(tmpMu1, tmpMu2)
h <- dim(H2)[1]
for (ii in 1:10000) {
tmpsel <- sample(1:300, 1)
Mu1 <- chart1$mu0[tmpsel] + tmpMu2[, tmpsel]
tmp <- BayesianLASSOMonitoring::simYph2(h, as.matrix(chart1$Y), rep(0, length(chart1$Y)),
as.matrix(chart1$Phi[, tmpsel]), Mu1, chart1$sigma2[tmpsel],
bset$updateYJ, bset$theta, bset$leftcensoring, bset$rounding, bset$eps, 1)
Yph1[, ii] <- tmp[1:(length(chart1$Y) - bset$q)]
Yph2[, ii] <- tmp[(length(chart1$Y)  - bset$q + 1):length(tmp)]
}
}
ph1pestmedian <- rep(NA, length(Y1) - bset$q)
if ((class(chart1)[1] != "try-error")) {
for (ii in 1:(length(Y1)  - bset$q)) {
ph1pestmedian[ii] <- median(Yph1[ii, ], na.rm = TRUE)
}
}
ph2pestmedian <- rep(NA, length(Y2))
if (class(chart1)[1] != "try-error") {
for (ii in 1:length(Y2)) {
ph2pestmedian[ii] <- median(Yph2[ii, ], na.rm = TRUE)
}
}
out <- rep(NA, 14)
if (class(chart1)[1] != "try-error") {
q <- dim(chart1$Phi)[1]
RMSE.ph1.median <- sqrt(mean((Y1[-c(1:q)] - ph1pestmedian) ^ 2, na.rm = TRUE))
RMSE.ph2.median <- sqrt(mean((Y2 - ph2pestmedian) ^ 2, na.rm = TRUE))
out <- c(RMSE.ph1.median,
RMSE.ph2.median)
###############################################
#chart 2
###############################################
start.exact <- ceiling(TT1 * tt) - q
end <- ceiling(TT1 * tt) - q
if (class(chart2)[1] != "try-error"){
TP.app <- sum(chart2$sig[start.exact:end], na.rm =TRUE)
FN.app <- sum(1 - chart2$sig[start.exact:end], na.rm =TRUE)
sensitivity.app <- TP.app / (TP.app + FN.app)
TN.app <- sum(1 - chart2$sig[-c(start.exact:end)], na.rm =TRUE)
FP.app <- sum(chart2$sig[-c(start.exact:end)], na.rm =TRUE)
specificity.app <- TN.app / (TN.app + FP.app)
ppv.app <- TP.app / (TP.app + FP.app)
sig <- chart2$grandsig
out <- c(out, sig,
sensitivity.app,
specificity.app,
ppv.app)
} else {
out <- c(out, rep(NA, 4))
}
###############################################
#chart 3
###############################################
start.exact <- ceiling(TT1 * tt) - q - 6
end <- ceiling(TT1 * tt) - q - 6
if (class(chart3)[1] != "try-error"){
TP.app <- sum(chart3$sig[start.exact:end], na.rm =TRUE)
FN.app <- sum(1 - chart3$sig[start.exact:end], na.rm =TRUE)
sensitivity.app <- TP.app / (TP.app + FN.app)
TN.app <- sum(1 - chart3$sig[-c(start.exact:end)], na.rm =TRUE)
FP.app <- sum(chart3$sig[-c(start.exact:end)], na.rm =TRUE)
specificity.app <- TN.app / (TN.app + FP.app)
ppv.app <- TP.app / (TP.app + FP.app)
sig <- chart3$grandsig
out <- c(out, sig,
sensitivity.app,
specificity.app,
ppv.app)
} else {
out <- c(out, rep(NA, 4))
}
###############################################
#chart 4
###############################################
start.exact <- ceiling(TT1 * tt) - q - 13
end <- ceiling(TT1 * tt) - q - 13
if (class(chart4)[1] != "try-error"){
TP.app <- sum(chart4$sig[start.exact:end], na.rm =TRUE)
FN.app <- sum(1 - chart4$sig[start.exact:end], na.rm =TRUE)
sensitivity.app <- TP.app / (TP.app + FN.app)
TN.app <- sum(1 - chart4$sig[-c(start.exact:end)], na.rm =TRUE)
FP.app <- sum(chart4$sig[-c(start.exact:end)], na.rm =TRUE)
specificity.app <- TN.app / (TN.app + FP.app)
ppv.app <- TP.app / (TP.app + FP.app)
sig <- chart4$grandsig
out <- c(out, sig,
sensitivity.app,
specificity.app,
ppv.app)
} else {
out <- c(out, rep(NA, 4))
}
###############################################
}
return(out)
}
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
ar <- pars[X, 12]
innovdist <- pars[X, 13]
Xf1 <- BayesianLASSOMonitoring::getXSeasonalityFS(TT1 + TT2 + 5000, 7, 2)
Xf2 <- BayesianLASSOMonitoring::getXSeasonalityFS(TT1 + TT2 + 5000, 30.4375, 5)
tmpdate <- as.Date("2017-01-01") + 0:(TT1 + TT2 + 5000 - 1)
businessday <- tis::isBusinessDay(tmpdate)
holiday <- tis::isHoliday(tmpdate)
Xreg <- cbind(Xf1, Xf2, businessday, holiday)
Xreg1 <- Xreg[1:(TT1 + TT2), ]
##debug(BayesianLASSOMonitoring::rarma)
Y <- rar(ar, TT1 + TT2, ceiling(TT1 * tt), delta, dist.innov = "gamma")
Y1 <- Y[1:(TT1)]
Y2 <- Y[(TT1 + 1):(TT1 + TT2)]
#H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
#H2 <- matrix(1, nrow = TT2, ncol = TT1 - q)
#H2sim <- matrix(1, nrow = 5000, ncol = TT1 - q)
H1 <- BayesianLASSOMonitoring::getHMatMT(TT1, q)
if (w > 1) {
H1 <- H1[, seq(1, TT1 - q, w)]
H1 <- H1[, -c(colSums(H1) < w)]
}
H2<- matrix(1, nrow = TT2, ncol = dim(H1)[2])
H2sim <- matrix(1, nrow = 5000, ncol = dim(H1)[2])
adjZ <- rep(0, TT1)
Zlb <- rep(0, TT1)
Zub <- rep(0, TT1)
bset1 <- list(
"method" = "MT",
"mono" = 0,
"q" = 5,
"A" = diag(rep(1, 5), nrow = 5),
"bound0" = Inf,
"boundqplus1" = 0,
"xi2" = 0.1,
"theta1" = 1,
"theta2" = 1,
"a" = 1,
"b" = 1,
"alpha" = 1,
"beta" = 1,
"updateYJ" = 1,
"adjZ" = adjZ,
"Zlb" = Zlb,
"Zub" = Zub,
"omega2" = 0.03,
"lambda2" = NULL,
"theta" = 1,
"eps" = 1e-32,
"nsim" = 300,
"thin" = 10,
"burnin" = 2000,
"leftcensoring" = 0,
"rounding" = 0
)
bset2 <- bset1
bset2$method <- "regression"
bset2$mono <- 0
bset3 <- bset1
bset3$method <- "LASSO"
bset3$mono <- 0
bset4 <- bset1
bset4$method <- "ALASSO"
bset4$mono <- 0
bset5 <- bset1
bset5$method <- "LASSO"
bset5$mono <- 1
bset6 <- bset1
bset6$method <- "ALASSO"
bset6$mono <- 1
out <-  rep(NA, 6 * 14)
out1 <- getChart(Y1,  H1, Y0,
side, FAP0,
Y2, H2, tt, TT1, X1, X2, bset1, w)
out1
if (class(out1)[1] == "try-error") {
out1 <- rep(NA, 14)
}
out2 <- getChart(Y1, H1, Y0,
side, FAP0,
Y2, H2, tt, TT1, X1, X2, bset2, w)
if (class(out2)[1] == "try-error") {
out2 <- rep(NA, 14)
}
out3 <- getChart(Y1, H1, Y0,
side, FAP0,
Y2, H2, tt, TT1, X1, X2, bset3, w)
if (class(out3)[1] == "try-error") {
out3 <- rep(NA, 14)
}
out4 <- getChart(Y1, H1, Y0,
side, FAP0,
Y2, H2, tt, TT1, X1, X2, bset4, w)
if (class(out4)[1] == "try-error") {
out4 <- rep(NA, 14)
}
out5 <- getChart(Y1, H1, Y0,
side, FAP0,
Y2, H2, tt, TT1, X1, X2, bset5, w)
if (class(out5)[1] == "try-error") {
out5 <- rep(NA, 14)
}
out6 <- getChart(Y1, H1, Y0,
side, FAP0,
Y2, H2, tt, TT1, X1, X2, bset6, w)
if (class(out6)[1] == "try-error") {
out6 <- rep(NA, 14)
}
out <- c(out1, out2, out3, out4, out5, out6)
cat("Gibbs Done at X:", X, "\n")
tmp <- try(forecast::auto.arima(Y1, xreg = X1, method = "CSS"), silent = TRUE)
if (class(tmp)[1] != "try-error") {
ph1 <- tmp$fitted
ph1[which(ph1 < 0)] <- 0
RMSE.ph1.arima <- sqrt(mean(((Y1 - ph1)^2)))
ph2 <- forecast::forecast(tmp, h = length(Y2), xreg = X2)$mean
ph2[which(ph2 < 0)] <- 0
RMSE.ph2.arima <- sqrt(mean((Y2 - ph2) ^ 2))
}
out <- c(out, RMSE.ph1.arima, RMSE.ph2.arima)
tmp
tmp <- try(forecast::auto.arima(Y1, method = "CSS"), silent = TRUE)
if (class(tmp)[1] != "try-error") {
ph1 <- tmp$fitted
ph1[which(ph1 < 0)] <- 0
RMSE.ph1.arima <- sqrt(mean(((Y1 - ph1)^2)))
ph2 <- forecast::forecast(tmp, h = length(Y2), xreg = X2)$mean
ph2[which(ph2 < 0)] <- 0
RMSE.ph2.arima <- sqrt(mean((Y2 - ph2) ^ 2))
}
tmp <- try(forecast::auto.arima(Y1, method = "CSS"), silent = TRUE)
if (class(tmp)[1] != "try-error") {
ph1 <- tmp$fitted
ph1[which(ph1 < 0)] <- 0
RMSE.ph1.arima <- sqrt(mean(((Y1 - ph1)^2)))
ph2 <- forecast::forecast(tmp, h = length(Y2))$mean
ph2[which(ph2 < 0)] <- 0
RMSE.ph2.arima <- sqrt(mean((Y2 - ph2) ^ 2))
}
out <- c(out, RMSE.ph1.arima, RMSE.ph2.arima)
out
Rcpp::compileAttributes()
roxygen2::roxygenise()
install.packages("dfphase1")
seed <- 12345
load(file = "/Users/yuihuiyao/Library/CloudStorage/Box-Box/2024 Spring/Temporal and Geographical Project for Opioid-overdose ER vistis/dataset/walker_BUPRENORPHINE_model2.Rdat")
object <- walker_BUPRENORPHINE_model2
nnsim <- 100
TT1 <- c(92, 183)
TT2 <- 365
w <- c(14)
#w <- 7
q <- 5
delta <- c(0, 0.5, 1)
tt <- 0.8
Y.hat.method <- c("median")
side <- "right-sided"
FAP0 <- 0.05
log <- c(FALSE)
sta <- c(FALSE)
pars <- expand.grid(TT1, TT2, w, q, delta, tt, Y.hat.method, side, FAP0, log, sta, 1:nnsim)
X <- 1
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
Xf1 <- BayesianLASSOMonitoring::getXSeasonalityFS(TT1 + TT2 + 5000, 7, 2)
Xf2 <- BayesianLASSOMonitoring::getXSeasonalityFS(TT1 + TT2 + 5000, 30.4375, 5)
tmpdate <- as.Date("2017-01-01") + 0:(TT1 + TT2 + 5000 - 1)
businessday <- tis::isBusinessDay(tmpdate)
holiday <- tis::isHoliday(tmpdate)
Xreg <- cbind(Xf1, Xf2, businessday, holiday)
Xreg1 <- Xreg[1:(TT1 + TT2), ]
##debug(BayesianLASSOMonitoring::rarma)
Y <- BayesianLASSOMonitoring::rarma(object, xreg = Xreg1, n = TT1 + TT2, h = ceiling(TT1 * tt), delta = delta)
debug(BayesianLASSOMonitoring::rarma)
Y <- BayesianLASSOMonitoring::rarma(object, xreg = Xreg1, n = TT1 + TT2, h = ceiling(TT1 * tt), delta = delta)
remove.packages("BayesianLASSOMonitoring")
devtools::install_github("bolus123/BayesianLASSOMonitoring", "with-transformation")
seed <- 12345
load(file = "/Users/yuihuiyao/Library/CloudStorage/Box-Box/2024 Spring/Temporal and Geographical Project for Opioid-overdose ER vistis/dataset/walker_BUPRENORPHINE_model2.Rdat")
object <- walker_BUPRENORPHINE_model2
nnsim <- 100
TT1 <- c(92, 183)
TT2 <- 365
w <- c(14)
#w <- 7
q <- 5
delta <- c(0, 0.5, 1)
tt <- 0.8
Y.hat.method <- c("median")
side <- "right-sided"
FAP0 <- 0.05
log <- c(FALSE)
sta <- c(FALSE)
pars <- expand.grid(TT1, TT2, w, q, delta, tt, Y.hat.method, side, FAP0, log, sta, 1:nnsim)
X <- 1
set.seed(seed + X)
TT1 <- pars[X, 1]
TT2 <- pars[X, 2]
w <- pars[X, 3]
q <- pars[X, 4]
delta <- pars[X, 5]
tt <- pars[X, 6]
Y.hat.method <- as.character(pars[X, 7])
side <- as.character(pars[X, 8])
FAP0 <- pars[X, 9]
log <- pars[X, 10]
sta <- pars[X, 11]
Xf1 <- BayesianLASSOMonitoring::getXSeasonalityFS(TT1 + TT2 + 5000, 7, 2)
Xf2 <- BayesianLASSOMonitoring::getXSeasonalityFS(TT1 + TT2 + 5000, 30.4375, 5)
tmpdate <- as.Date("2017-01-01") + 0:(TT1 + TT2 + 5000 - 1)
businessday <- tis::isBusinessDay(tmpdate)
holiday <- tis::isHoliday(tmpdate)
Xreg <- cbind(Xf1, Xf2, businessday, holiday)
Xreg1 <- Xreg[1:(TT1 + TT2), ]
##debug(BayesianLASSOMonitoring::rarma)
Y <- BayesianLASSOMonitoring::rarma(object, xreg = Xreg1, n = TT1 + TT2, h = ceiling(TT1 * tt), delta = delta)
Y
BayesianLASSOMonitoring::rarma
Y
debug(BayesianLASSOMonitoring::rarma)
Y <- BayesianLASSOMonitoring::rarma(object, xreg = Xreg1, n = TT1 + TT2, h = ceiling(TT1 * tt), delta = delta)
theta.vec
phi.vec
sigma.mat(100, order = order, phi.vec = phi.vec, theta.vec = theta.vec,
sigma2 = object$sigma2, burn.in = burnin)
debug(sigma.mat)
sigma.mat(100, order = order, phi.vec = phi.vec, theta.vec = theta.vec,
sigma2 = object$sigma2, burn.in = burnin)
phiMat
thetaMat
thetaMat
norder
order[3]
thetaMat <- pars.mat(n + burn.in, theta.vec, norder = order[3])
thetaMat
pars.mat
?
>
##############################################
# Matrix form
##############################################
invert.q <- function(coef) {
out <- 1
if (all(abs(coef) < 1)) {
minmod <- min(Mod(polyroot(c(1, coef))))
if (minmod <= 1) {
out <- 0
}
} else {
out <- 0
}
return(out)
}
pars.mat <- function(n, parsVec, norder = 1, checkinv = TRUE) {
Check <- 1
if (checkinv == TRUE) {
Check <- invert.q(parsVec)
}
if (Check == 0) {
NULL
} else {
Mat <- diag(n)
for (i in 1:norder) {
Mat <- Mat + Diag(rep(parsVec[i], n - i), k = -i)
}
Mat
}
}
#' simulate realizations using INAR(3) with zero-inflated Poisson innovation and one sustained shift
#'
#' @param n is the length
#' @param alpha is the alpha
#' @param lambda is the mean of poisson mixture
#' @param pi is the proportion of zeros
#' @param h is the start point of shift
#' @param delta is the value of the standardized shift
#' @param burnin is the length of the burn-in period
#' @export
#' @examples
#' nsim <- 100
#' burnin <- 100
#' T <- 100
#' q <- 5
#' H <- getHMatMT(T, q)
#' Y <- arima.sim(list(ar = 0.5), n = T)
#'
#' alpha <- c(0.03083069, 0.06242601, 0.09120189)
#' lambda <- 0.239385
#' pi <- 0.1453097
#'
#' TT <- 183
#' w <- 28
#' Y <- rzinpoisinar3(TT + w, alpha, lambda, pi, ceiling(TT / 2) + w, delta = 1, burnin = burnin)
#'
sigma.mat <- function(n, order = c(1, 0, 0), phi.vec = 0.5, theta.vec = NULL, sigma2 = 1, burn.in = 50) {
if (order[1] == 0) {
phiMat <- diag(n + burn.in)
} else {
phiMat <- pars.mat(n + burn.in, -phi.vec, norder = order[1])
}
if (order[3] == 0) {
thetaMat <- diag(n + burn.in)
} else {
thetaMat <- pars.mat(n + burn.in, theta.vec, norder = order[3])
}
out <- solve(phiMat) %*% thetaMat %*% t(thetaMat) %*% t(solve(phiMat)) * sigma2
gamma0 <- out[dim(out)[1], dim(out)[2]]
if (burn.in > 0) {
out <- out[-c(1:burn.in), -c(1:burn.in)]
}
list(sigma.mat = out, sqrtsigma.mat = sqrtm(out)$B, gamma0 = gamma0)
}
remove.packages("BayesianLASSOMonitoring")
devtools::install_github("bolus123/BayesianLASSOMonitoring", "with-transformation")
